"use strict";
// JavaScript сам по себе не имеет инструментов для работы с браузером.
// JavaScript - DOM, BOM, ECMASCRIPT
// 1. DOM (Document Object Model, Объектная модель документа) —
// межплатформенный, независимый от языка интерфейс для работы с
// HTML-документом. Содержит набор свойств и методов позволяющих искать,
// создавать и удалять элементы, реагировать на действия пользователя и другое.
// 2. BOM (Browser Object Model, Объектная модель браузера) —
// межплатформенный, независимый от языка интерфейс для работы с окном
// браузера. Содержит набор свойств и методов позволяющих получить доступ
// непосредственно к текущей вкладке и ряду функций браузера. Включает объект
// работы с историей, местоположением и другое.

// Объектная модель документа - DOM
// DOM является отражением HTML-документа.
// DOM выполняет две роли: является объектным представлением
// HTML-документа, и действует как интерфейс, соединяющий страницу
// с языком программирования, например JavaScript.
// Каждый элемент в документе, весь документ в целом, заголовок, ссылка,
// абзац — это части DOM этого документа, поэтому все они могут
// изменяться с помощью JavaScript.
// Согласно DOM-модели каждый тег образует отдельный элемент-узел,
// каждый фрагмент текста — текстовый элемент, таким образом
// HTML-документ это иерархическое дерево.
// DOM-узел это объект. У него есть методы и свойства.
// Чтобы отобразить HTML-документ, браузер сначала преобразовавает
// его в формат который он понимает — DOM. У движка браузера есть
// специальный фрагмент кода — HTML-парсер, который используется для преобразования HTML в DOM.
// В HTML, вложенность определяет отношения родитель-ребенок между
// элементами. В DOM, объекты связаны в древовидной структуре данных,
// фиксируя эти отношения.
// После того как DOM-дерево построено, можно найти в нем элемент с
// помощью JavaScript и выполнять с ним какие-то действия, так как
// каждый узел имеет интерфейс с множеством свойств и методов.
// Узлы-элементы (element node) — образуются тегами, естественным образом одни узлы вложены в другие.
// Структура дерева образована исключительно за счет них.
// Текстовые узлы (text node) — образуются текстом внутри элементов.
// Текстовый узел содержит только строку текста и не может иметь потомков,
// то есть он всегда на самом нижнем уровне иерархии. Пробелы и
// переносы строк это тоже текстовые узлы.

// Навигация по DOM
// Доступ к DOM начинается с объекта document, от него можно добраться до любых узлов.
// Термины ancestor (предок), descendant (потомок), parent (родитель),
// child (ребенок) и sibling (сосед) используются для описания отношений.
// В дереве узлов верхний узел называется корневым (root node).
// Каждый узел, кроме root node, имеет только одного родителя.
// У узла может быть сколько угодно детей.
// Соседи — это узлы с общим родителем.
// Дочерние элементы (дети) — элементы, которые лежат непосредственно внутри данного.
// Потомки – все элементы, которые лежат внутри данного, вместе с их
// детьми, детьми их детей и так далее. То есть всё поддерево.

// Свойства для навигации между узлами:
// elem.parentNode - выберет родителя elem
// elem.childNodes - псевдо-массив хранит все дочерние элементы, включая текстовые.
// elem.children - псевдо-массив хранит только дочерние узлы-элементы, то есть соответствующие тегам.
// elem.firstChild - выберет первый дочерний элемент внутри elem, включая текстовые узлы.
// elem.firstElementChild - выберет первый дочерний узел-элемент внутри elem.
// elem.lastChild - выберет последний дочерний элемент внутри elem, включая текстовые узлы.
// elem.lastElementChild - выберет последний дочерний узел-элемент внутри elem.
// elem.previousSibling - выберет элемент "слева" от elem (его предыдущего соседа)
// elem.previousElementSibling - выберет узел-элемент "слева" от elem (его предыдущего соседа)
// elem.nextSibling - выберет элемент "справа" от elem (его следующего соседа)
// elem.nextElementSibling - выберет узел-элемент "справа" от elem (его предыдущего соседа)

// Нахождение элемента по произвольному CSS-селектору.
// 1. elem.querySelector* это современный стандарт для поиска DOM-узлов.
// Они позволяют найти узел или группу узлов по CSS-селектору любой сложности.
// elem.querySelector(selector)
// Возвращает первый найденный элемент внутри elem, соответствующий CSS-селектору selector.
// Если ничего не найдено, вернет null.
// 2. elem.querySelectorAll(selector)
// Используется когда мы заведомо знаем, что подходящих элементов более одного.
// Возвращает псевдомассив всех элементов внутри elem, удовлетворяющих CSS-селектору selector.
// Если ничего не найдено вернет пустой массив.

// DOM - свойства и атрибуты
// hidden - контролирует видимость элемента.
// value - содержит текущий текстовый контент элементов input, select, textarea.
// checked - хранит состояние чекбокса или радиокнопки.
// name - хранит значение указанное в HTML-атрибуте name.
// src - путь к изображению тега <img>
// 1. Свойство Node.textContent
// elem.textContent — свойство, содержит текстовый контент внутри
// элемента. Доступно для записи, при чем вне зависимости что будет
// передано в textContent, данные всегда будут записаны как текст.
// 2. Свойство HTMLElement.style
// Используется для получения и установки инлайновых стилей. Возвращает
// объект CSSStyleDeclaration, который содержит список всех свойств
// определенных только в инлайновом стиле элемента, а не весь CSS.
// Свойство можно как читать так и записывать. При записи, свойства
// записываются в camelCase, то есть background-color превращается в
// element.style.backgroundColor и т. д.
// const button = document.querySelector(".btn");
// button.style.backgroundColor = "teal";
// console.log(button.style); // объект инлайн стилей
// 3. Свойство Element.classList
// elem.classList.contains(cls) - возвращает true или false, в зависимости от того, есть ли у элемента класс cls
// elem.classList.add(cls) - добавляет класс cls в список классов элемента
// elem.classList.remove(cls) - удаляет класс cls из списка классов элемента
// elem.classList.replace(oldClass, newClass) - заменяет существующий класс на указанный
// elem.classList.toggle(cls) - если класса cls нет, добавляет его, если есть, удаляет
// Атрибуты
// DOM-элементам соответствуют HTML-теги, у которых есть текстовые
// атрибуты. Доступ к атрибутам осуществляется при помощи стандартных методов.
// Эти методы работают со значением, которое находится в HTML.
// elem.hasAttribute(name) - проверяет наличие аттрибута, возвращает true или false
// elem.getAttribute(name) - получает значение атрибута и возвращает его
// elem.setAttribute(name, value) - устанавливает атрибут
// elem.removeAttribute(name) - удаляет атрибут
// elem.attributes - свойство, возвращает коллекцию всех атрибутов элемента

// Работа с DOM-узлами
// 1. Создание
// document.createElement(tagName)
// Создает HTML-элемент по указаному имени тега и возвращает ссылку на
// него как результат своего выполнения. tagName это строка, указывающая
// тип создаваемого элемента. Элемент создается в памяти, в DOM его еще нет.
// const heading = document.createElement("h1");
// console.log(heading); // <h1></h1>
// heading.textContent = "This is a heading";
// console.log(heading); // <h1>This is a heading</h1>
// const image = document.createElement("img");
// image.setAttribute("src", "https://placeimg.com/640/480/nature");
// image.setAttribute("alt", "nature");
// console.log(image); // <img src="https://placeimg.com/640/480/nature" alt="nature">
// 2. Добавление
// Чтобы созданный элемент был отображен на странице, его необходимо
// добавить к уже существующему элементу в DOM.
// parentElem.appendChild(elem)
// parentElem.insertBefore(elem, nextSibling)
// Добавляет elem в коллекцию детей parentElem, перед элементом
// nextSibling. Если вторым аргументом указать null, тогда insertBefore
// сработает как appendChild.
// Есть методы которые позволяют вставить что угодно и куда угодно.
// Во всех этих методах, nodes – DOM-узлы или строки, в любом сочетании
// и количестве. Причём строки вставляются как текстовые узлы.
// elem.append(nodes) - добавляет nodes в конец elem
// elem.prepend(nodes) - добавляет nodes в начало elem
// elem.after(nodes) - добавляет nodes после узла elem
// elem.before(nodes) - добавляет nodes перед узлом elem
// elem.replaceWith(nodes) - добавляет nodes вместо elem
// 3. Удаление
// Для того чтобы удалить узел существуют два метода
// parent.removeChild(elem)
// elem.remove()  -  более новый
// 4. Клонирование
// elem.cloneNode(true)
// Создаст глубокую копию элемента – вместе с атрибутами, включая все
// поддерево. Если же вызвать с аргументом false, то копия будет
// сделана без дочерних элементов.
// 5. Свойство innerHTML
// Еще один способ создать DOM-элементы и поместить их в дерево это
// использовать строки и позволить браузеру сделать всю тяжелую работу.
// elem.innerHTML — свойство, позволяет получить содержимое элемента,
// включая теги, в виде строки. Значение, возвращаемое innerHTML — всегда валидный HTML-код
// elem.innerHTML = '<p class="text">Pellentesque habitant.</p>';
// Такой код говорит браузеру распарсить строку, проверить на наличие
// тегов, если нашел таковые то создать DOM-элементы и вставить их в
// правильном порядке. При таком подходе, в отличии от createElement,
// мы не получаем ссылку на созданный DOM-элемент.
// Изменение innerHTML полностью удалит и пересоздаст всех потомков
// контейнера. В результате мы получаем дополнительные затраты на
// сериализацию уже существующей разметки, что не очень хорошо
// 6. Метод insertAdjacentHTML()
// element.insertAdjacentHTML(position, string)
// position — позиция относительно элемента. Принимает одно из следующих значений:
// 'beforebegin' - перед element
// 'afterbegin' - внутрь element, в самое начало контента
// 'beforeend' - внутрь element, в самый конец контента
// 'afterend' - после element
// beforebegin и afterend работают только в том случае, если узел
// уже находится в DOM-дереве и имеет родительский элемент.
// elem.insertAdjacentElement(position, elem) — вставляет в
// произвольное место не HTML-строку, а элемент elem.
// elem.insertAdjacentText(position, text) — создаёт текстовый узел
// из строки text и вставляет его в указанное место относительно elem.
// 7. Repaint
// Происходит когда изменения произошли в стилях элемента влияющих на
// внешний вид, но не на геометрию. Например opacity, background-color, visibility и outline.
// 8. Reflow
// Происходит когда изменения затрагивают содержимое, структуру
// документа, положение элементов. Идет пересчет позиционирования и
// размеров всех элементов, что ведет к перерисовке части или всего документа.

// События
// Событие – это сигнал от браузера о том, что что-то произошло.
// События используются для реакции на действия посетителя и исполнения
// кода. Cобытия становятся в очередь и обрабатываются в порядке поступления, асинхронно, независимо.
// click - происходит, когда кликнули на элемент левой кнопкой мыши
// submit - посетитель отправил форму
// focus - посетитель фокусируется на элементе, например нажимает на input
// keydown - посетитель нажимает клавишу
// 1. Слушатели событий
// Для того чтобы элемент реагировал на действия пользователя, на него
// необходимо повесить слушателя (обработчик) события. То есть функцию,
// которая сработает как только событие произошло. Именно благодаря
// слушателям событий, скрипт может реагировать на действия пользователя.
// 2. Метод elem.addEventListener()
// Добавляет слушателя события на элемент.
// element.addEventListener(event, handler[, phase])
// event - имя события, строка, например click
// handler - ссылка на функцию, которую надо поставить обработчиком
// phase - необязательный аргумент, фаза, на которой обработчик должен сработать. Указывается крайне редко.
// Если мы передаем функцию которая использует this, по умолчанию this
// внутри нее будет ссылаться на сам DOM-узел на котором висит слушатель.
// Не забывайте привязывать контекст используя метод bind.
// const user = {
//   name: 'Mango',
//   showName() {
//     console.log(this);
//     // this будет ссылаться на button если использовать showName как callback
//     console.log(`My name is: ${this.name}`);
//     // тут undefined так как поля name у button нет
//   },
// };
// /*
//  * Представим что у нас есть кнопка с классом js-btn
//  * Выберем ее и повесим на нее слушатель клика
//  */
// const btn = document.querySelector('.js-btn');
// user.showName(); //работает
// btn.addEventListener('click', user.showName); // не работает
// btn.addEventListener('click', user.showName.bind(user)); // работает
// 3. Метод elem.removeEventListener()
// Удаляет слушателя. Аргументы те же что у addEventListener.
// element.removeEventListener(event, handler[, phase])
// 3. Объект события
// Объект события содержит ценную информацию о деталях события и
// автоматически передается первым аргументом в обработчик события.
// event.type - тип события
// event.target - элемент, на котором произошло событие
// event.currentTarget - элемент, на котором сработал обработчик
// 4. Действия браузера по умолчанию
// Некоторые события автоматически вызывают действие браузера
// встроенное по умолчанию как реакция на определенный тип события:
// переход по ссылке, отправка формы и т. п. Как правило их можно, и зачастую нужно, отменить.
// Клик по ссылке инициирует переход на новый URL указанный в href ссылки.
// Отправка формы — перезагрузку страницы.
// Для отмены действия браузера по умолчанию, на объекте события есть стандартный метод.
// event.preventDefault()
// Событие submit
// Возникает при отправке формы. Его применяют для валидации (проверки)
// формы перед отправкой. Чтобы отправить форму, у посетителя есть два способа:
// Нажать кнопку с type="submit"
// Нажать клавишу Enter, находясь в каком-нибудь поле формы
// Какой бы способ ни выбрал посетитель – будет сгенерировано событие
// submit. В обработчике этого события можно проверить данные, и выполнить действия по результатам проверки.
// 5. События клавиатуры
// Есть три основных события клавиатуры: keydown, keypress и keyup.
// При нажатии клавиши сначала происходит keydown, после чего keypress,
// и только потом keyup, когда клавишу отжали.
// События keydown и keyup срабатывают при нажатии любой клавиши,
// включая служебные. А вот keypress срабатывает только если нажата
// символьная клавиша, т. е. нажатие приводит к появлению символа
// Свойство KeyboardEvent.key доступно для чтения и возвращает значение
// клавиши, нажатой пользователем, принимая во внимание состояние клавиш
// модификаторов, таких как shiftKey, а так же текущий язык и модель клавиатуры.
// Свойство KeyboardEvent.code представляет собой физическую клавишу
// на клавиатуре (в отличие от символа, сгенерированного нажатием клавиши).
// Другими словами, это свойство возвращает значение, которое не изменяется
// с помощью раскладки клавиатуры или состояния клавиш-модификаторов.
// 6. События элементов форм
// Фокусировка
// Элемент получает фокус при нажатии на нем мышкой, клавиши Tab или
// выбрав на планшете. Момент получения фокуса и потери очень важен,
// при получении фокуса мы можем подгрузить данные для автодополнения,
// начать отслеживать изменения. При потере фокуса — проверить введенные данные.
// При фокусировке на элемент происходит событие focus, а когда фокус
// исчезает, например посетитель кликает в другом месте экрана, происходит событие blur.
// фокус может быть только на одном элементе в единицу времени, и
// текущий элемент, на котором фокус, доступен как document.activeElement.
// Активировать или отменить фокус можно программно, вызвав в коде
// одноименные методы elem.focus() и elem.blur() у элемента.
// Событие input
// Срабатывает только на текстовых элементах, input:text и textarea,
// при изменении значения элемента. Не ждет потери фокуса, в отличие от change.
// В современных браузерах input — самое главное событие для работы с
// текстовым элементом формы. Именно его, а не keydown или keypress, следует использовать.
// 7. Загрузка документа
// При открытии веб-страницы, процесс загрузки HTML-документа условно
// состоит из трёх стадий. На каждую можно повесить обработчик, чтобы совершить действия.
// DOMContentLoaded — браузер полностью загрузил HTML и построил DOM-дерево.
// load — браузер загрузил все ресурсы.
// beforeunload и unload — уход со страницы.
// DOMContentLoaded
// Происходит на document когда все DOM-элементы разметки уже созданы,
// можно их искать, вешать обработчики, создавать интерфейс, но при
// этом, возможно, ещё не догрузились какие-то картинки или стили.
// document.addEventListener('DOMContentLoaded', callback)
// load
// Событие срабатывает на window, когда загружается вся страница,
// включая ресурсы на ней — стили, картинки и т.д. Его используют
// редко, поскольку обычно нет нужды ждать загрузки всех ресурсов.
// unload
// Когда человек уходит со страницы или закрывает окно, на window
// срабатывает событие unload. В нём можно сделать что-то, не требующее
// ожидания, например, закрыть вспомогательные popup-окна, но отменить
// сам переход нельзя. Событие почти не используется — мало что можно сделать, зная, что вкладка браузера сейчас закроется.
// beforeunload
// Событие срабатывает на window. Это стандарт для того, чтобы проверить,
// сохранил ли посетитель данные, действительно ли он хочет покинуть страницу.
// Если посетитель инициировал переход на другую страницу или нажал
// закрыть окно, то обработчик beforeunload может приостановить процесс
// и спросить подтверждение. Для этого ему нужно вернуть строку,
// которую браузеры покажут посетителю, спрашивая – нужно ли переходить.

// Процесс построения веб-страницы
// Когда браузер создает DOM, если он встречает тег script в HTML, он должен выполнить его сразу.
// Когда синтаксический анализатор попадает в тег сценария, конструкция
// DOM не может продолжаться до тех пор, пока JavaScript не завершит
// выполнение, и JavaScript не будет выполнен до тех пор, пока CSS
// не будет загружен, проанализирован и не будет доступен CSSOM.
// Атрибуты defer и async
// Атрибуты defer и async были введены, чтобы дать разработчикам
// возможность рассказать браузеру, какие скрипты обрабатывать асинхронно.
// Оба атрибута сообщают браузеру, что он может продолжить разбор HTML
// при загрузке сценария в фоновом режиме, а затем выполнить скрипт после его загрузки
// Результат: пользователь может видеть страницу до того, как все сценарии завершили загрузку.
// Разница между ними - это тот момент, когда загруженые скрипты начинают выполняться.
// Выполнение defer скриптов начинается после завершения парсинга,
// но перед событием DOMContentLoaded. Это гарантирует, что скрипты
// будут выполняться в том порядке, в котором они отображаются в HTML,
// и не будут блокировать синтаксический анализатор.
// <script src="path-to-script.js" defer></script>
// async выполняется при первой возможности после завершения загрузки
// и перед событием загрузки окна. Это означает, что возможно скрипты
// не выполняются в том порядке, в котором они отображаются в HTML.
// Это также означает, что они могут прервать создание DOM.
// <script src="path-to-script.js" async></script>
// Однако, если async скрипт завершает загрузку раньше, его выполнение
// может блокировать создание DOM и все синхронные скрипты, которые
// впоследствии завершают загрузку.

//
//
// Примеры

// Варианты получения доступа к элементу html
// 1. Через имя тега
const title = document.querySelector("h1");
title.textContent = "Перезаписываю значение";
title.style.color = "blue";
title.style.backgroundColor = "yellow";

const list = document.querySelector("ul");
list.classList.add("myNewClass");
list.classList.remove("myNewClass");

const image = document.querySelector("img");
image.setAttribute("alt", "nature");
image.src =
  "https://images.pexels.com/photos/5108638/pexels-photo-5108638.jpeg?auto=compress&cs=tinysrgb&dpr=1&w=500";
image.width = 200;
image.height = 200;
image.removeAttribute("height");

// 2. Через класс
// 1)
// const title = document.querySelector(".main-title");
// 2)
// const title = document.getElementsByClassName("main-title");

// 3. Через идентификатор
// 1)
// const title = document.querySelector("#titles");
// 2)
// const title = document.getElementById("titles");

// 4. Через  data-atribute
// const title = document.querySelector(`[data-action="action"]`);
console.log(title);
console.dir(title);

// Создание элемента
const newLi = document.createElement("li");
newLi.textContent = "4";
console.log(newLi);
list.appendChild(newLi); // добавляет один элемент
list.append(); // добавляет несколько элементов
newLi.remove();

const beforeList = document.createElement("a");
beforeList.textContent = "1";

const beginList = document.createElement("a");
beginList.textContent = "2";

const endList = document.createElement("a");
endList.textContent = "3";

const afterList = document.createElement("a");
afterList.textContent = "4";

list.style.border = "1px solid";
list.insertAdjacentElement("afterbegin", beginList);
list.insertAdjacentElement("beforebegin", beforeList);
list.insertAdjacentElement("beforeend", endList);
list.insertAdjacentElement("afterend", afterList);

const newImage = image.cloneNode(true);
list.insertBefore(newImage, endList);

const desk = `<h2 style="color:green">Hello!</h2>`;
list.insertAdjacentHTML("beforebegin", desk);
console.dir(desk);
console.dir(endList);

list.removeChild(endList);
afterList.remove();

// list.innerHTML = "";
// list.innerHTML = `<li>1</li> <li>2</li> <li>3</li>`;

const button = document.querySelector("button");
button.addEventListener("click", () => {
  console.log("Обработка клика по кнопке");
  console.log(event.type);
  console.log(event.target); // элемент на котором произошло событие
  console.log(event.currentTarget); // элемент на котром сработал обработчик события
  list.style.border = "10px solid red";
});

const form = document.querySelector("form");
form.addEventListener("submit", (event) => {
  event.preventDefault();
  console.log("Обработка события submit");
  console.dir(form);
});
const input = document.querySelector(".input");
input.addEventListener("input", () => {
  console.log("Обработка события submit");
  console.dir(input.value);
});
input.addEventListener("focus", () => {
  input.style.backgroundColor = "green";
  console.dir(input);
});
input.addEventListener("blur", () => {
  input.style.border = "2px solid red";
  input.style.backgroundColor = "white";
  console.dir(input);
});
input.addEventListener("change", () => {
  console.dir(input.value);
});

document.addEventListener("DOMContentLoaded", () => {
  console.log("Произошла загрузка страницы");
});
document.addEventListener("load", () => {
  console.log("Страница загрузилась полностью");
});
document.addEventListener("beforeunload", () => {
  confirm("Вы покидаете страницу");
});

const buttonsList = document.querySelector(".buttons");
buttonsList.style.border = "2px solid";
buttonsList.addEventListener("click", () => {
  console.log(event.target);
  console.log(event.currentTarget);
});

form.addEventListener("input", () => {
  console.log(event.target);
  console.log(event.currentTarget);
  let value = event.target;
  console.log(value.value);
});
