"use strict";
// Распространение событий (event propagation)
// включает в себя три разных этапа жизни события: затопление, таргетинг и всплытие.
// Распространение события двунаправлено — оно начинается на window, идет
// к целевому элементу и заканчивается на window.  Каждый раз, когда
// происходит событие, происходит его распространение.
// 1. Capture phase — событие начинается на window и тонет (проходит через
// все узлы-предки ) до самого глубокого целевого элемента , где произошло событие.
// 2. Target phase — событие дошло до самого глубокого целевого элемента.
// Этот этап включает только уведомление узла, на котором произошло событие.
// 3. Bubbling phase — заключительная фаза, событие всплывает от самого глубокого,
// целевого элемента, через все узлы-предки, до window.

// Всплытие событий
// Основной принцип всплытия — при наступлении события, обработчики сначала
// срабатывают на самом вложенном элементе, затем на его родителе, затем
// выше и так далее, вверх по цепочке вложенности. Всплывают почти все
// события, например события focus и blur не всплывают.

// event.target
// Целевой элемент — на каком бы элементе мы ни поймали событие, всегда
// можно узнать где конкретно оно произошло. Самый глубокий элемент, который
// вызывает событие, называется целевым или исходным и доступен как event.target.
// event.target — это ссылка на исходный элемент, на котором произошло
// событие, в процессе всплытия он неизменен.
// event.currentTarget — это текущий элемент, до которого дошло всплытие,
// на нём сейчас выполняется обработчик.

// Прекращение всплытия
// Остановить всплытие можно вызвав метод на объекте события.
// event.stopPropagation()
// То есть, stopPropagation препятствует продвижению события дальше, но
// на текущем элементе все обработчики выполнятся.
// event.stopImmediatePropagation()
// Используется для того, чтобы полностью остановить обработку события.
// Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.
// Не прекращайте всплытие без необходимости, всплытие – это удобно!
// Прекращение всплытия создаёт свои подводные камни, которые потом приходится обходить.

// Делегирование событий
// Всплытие событий позволяет реализовать один из самых важных приёмов
// разработки — делегирование событий. Он заключается в том, что если есть
// много элементов, события которых нужно обрабатывать похожим образом, то
// вместо того чтобы назначать обработчик каждому, мы ставим один обработчик на их общего предка.
// Делегирование (event delegation) — это средство оптимизации интерфейса.
// Мы используем один обработчик (event listener) для схожих действий на однотипных элементах.
// Используем event.target, чтобы получить элемент, на котором произошло событие.
// Для проверки типа узла используем свойство nodeName.

//
//
// Throttle и Debounce
// Throttle и Debounce - это два похожих (но разных по поведению) приема,
// позволяющих контролировать, сколько раз мы разрешаем выполнение функции с течением времени.
// Используя эти два подхода мы не контролируем как часто браузер будет
// генерировать события. Мы всего-лишь берем контроль над частотой
// выполнения callback-функции переданной в обработчик события.
// Throttle
// Прием throttle обеспечивает контроль над количеством раз, которое
// функция может быть вызвана в течение промежутка времени. То есть
// позволяет выполнять функцию не чаще чем один раз в N миллисекунд,
// гарантируя ее регулярное выполнение.
// window.addEventListener(
//   "scroll",
//   _.throttle(() => {
//     console.log("Scroll event handler invocation every 300ms.");
//   }, 300)
// );
// Debounce
// Прием debounce гарантирует, что функция не будет вызывана снова, пока
// не пройдет определенное количество времени без ее вызова. То есть позволяет
// выполнить функцию, только если прошло N миллисекунд без ее вызова, группируя множественные вызовы в один.
// document.querySelector('input').addEventListener(
//   'input',
//   _.debounce(() => {
//     console.log(
//       'Input event handler invocation after 300ms of inactivity past burst.',
//     );
//   }, 300),
// );

//
//
// Intersection Observer API
// новый способ обработки событий прокрутки. Этот интерфейс предоставляет
// возможность наблюдать за заданными элементами и упрощает реализацию
// отслеживания изменения в их пересечении с заданным элементом-предком
// или самим окном просмотра (viewport), то есть слежения за видимостью элемента.
// Intersection Observer передает управление событиями пересечения браузеру,
// который управляет этими событиями более эффективно, улучшая производительность.
// Концепция Intersection Observer
// 1. Observer (наблюдатель, обзервер) - результат вызова класса IntersectionObserver,
// его экземпляр, объект с методами.
// 2. Root (корень, контекст) - это элемент, который ожидает пересечения
// элемента-цели. Основа наблюдателя. По умолчанию это окно просмотра браузера
// (viewport), но может использоваться любой другой элемент, если этого требует задача.
// 3. Target (цель) - элемент, за которым следит наблюдатель и оповещает
// о его вхождении в корень. Целью может быть любой элемент. Один наблюдатель
// может отслеживать множество различных целей.

// Использование Intersection Observer
// IntersectionObserver(callback, options)
// Первым аргументом коллбэк получит массив объектов IntersectionObserverEntry,
//  каждый из которых содержит набор свойств элемента, показываемого в области
// видимости: boundingClientRect, intersectionRatio, intersectionRect, rootBounds,
// target и time. Вторым агументом в колбек передается ссылка на сам экземпляр обзервера.
// Объект настроек позволяет задать опции, с которыми будет создан обзервер.
// Можно изменить контекст (root), который по умолчанию равен viewport,
// задать отступы от границ контекста (rootMargin) — по умолчанию 0px.
// И порог вхождения (threshold) в виде массива значений. Порог означает,
// сколько процентов элемента должно попасть в область видимости для
// срабатывания коллбэка. Значения могут варьироваться от 0.01 до 1.0.
// const options = {
//   rootMargin: "50px",
//   threshold: 0.5,
// };
// const onEntry = (entries, observer) => {
//   entries.forEach((entry) => {
//     // тут можно писать логику для проверки вхождения
//   });
// };
// const observer = new IntersectionObserver(onEntry, options);
// После того как экземпляр IntersectionObserver создан, необходимо
// предоставить один или несколько целевых элементов для наблюдения
// const options = {
//   rootMargin: "50px",
//   threshold: 0.5,
// };
// const onEntry = (entries, observer) => {
//   entries.forEach((entry) => {
//     // тут можно писать логику для проверки вхождения
//   });
// };
// const observer = new IntersectionObserver(onEntry, options);
// observer.observe(elem);
